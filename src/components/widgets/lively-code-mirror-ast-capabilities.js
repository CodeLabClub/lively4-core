import { loc, range } from 'utils';

import ContextMenu from 'src/client/contextmenu.js';
import FileIndex from "src/client/fileindex.js";

import babelDefault from 'systemjs-babel-build';
const babel = babelDefault.babel;

const t = babel.types;
const template = babel.template;

export default class ASTCapabilities {

  constructor(livelyCodeMirror, codeMirror) {
    this.livelyCodeMirror = livelyCodeMirror;
    this.codeMirror = codeMirror;
  }
  get editor() {
    return this.codeMirror;
  }
  get selectionRanges() {
    return this.editor.listSelections().map(range);
  }

  /*MD ## Navigation MD*/
  /**
   * Get the root path
  */
  get programPath() {
    let programPath;
    this.sourceCode.traverseAsAST({
      Program(path) {
        programPath = path;
      }
    });
    return programPath;
  }

  /** 
   * Return first child in depth first search that satisfies a condition
   */
  nextPath(startingPath, isValid) {
    let pathToShow;

    startingPath.traverse({
      enter(path) {
        if (!pathToShow && isValid(path)) {
          pathToShow = path;
        }
      }
    });

    return pathToShow;
  }

  /**
   * Return the last valid path that is generated by a given callback function on the previous path
   */
  getLastPath(startingPath, nextPathCallback) {
    let pathToShow = startingPath;
    while (true) {
      let nextPath = nextPathCallback(pathToShow);
      if (nextPath) {
        pathToShow = nextPath;
      } else {
        break;
      }
    }

    return pathToShow;
  }

  /**
   * Returns the first child of a node or the node itself, if it has no children
   */
  getFirstChildOrSelf(startingPath) {
    let child;
    startingPath.traverse({
      enter(path) {
        if (!child) {
          child = path;
        }
      }
    });
    return child || startingPath;
  }

  /**
  * Returns the nearest path before the cursor location
  */
  getPathBeforeCursor(startingPath, anchor) {
    const selectionStart = loc(anchor);
    let foundPath;
    startingPath.traverse({
      exit(path) {
        const pathLocation = path.node.loc;
        const pathEnd = loc(pathLocation.end);
        if (selectionStart.isBefore(pathEnd)) {
          path.stop();
          return;
        }
        foundPath = path;
      }
    });
    return foundPath;
  }

  /**
   * Returns the innermost node, that contains the selected text.
   */
  getInnermostPathContainingSelection(startingPath, anchor, head) {
    // go down to minimal selected node
    const nextPathContainingCursor = (newStartingPath, { anchor, head }) => {
      return this.nextPath(newStartingPath, path => {
        const location = range(path.node.loc);
        return location.contains(anchor) && location.contains(head);
      });
    };
    return this.getLastPath(startingPath, prevPath => nextPathContainingCursor(prevPath, { anchor, head }));
  }

  getSelectedPaths(programPath) {
    return this.editor.listSelections().map(({ anchor, head }) => {
      const selectionStart = loc(anchor);
      const selectionEnd = loc(head);
      const pathContainingWholeSelection = this.getInnermostPathContainingSelection(programPath, anchor, head);

      //path already matches the selection
      if (this.isPathExactlySelected(pathContainingWholeSelection, { selectionStart, selectionEnd })) {
        return pathContainingWholeSelection;
      }

      //find children that match the selection
      let selectedPaths = [];
      pathContainingWholeSelection.traverse({
        enter(path) {
          const pathLocation = path.node.loc;
          const pathStart = loc(pathLocation.start);
          const pathEnd = loc(pathLocation.end);
          if (!(pathEnd.isBefore(selectionStart) || selectionEnd.isBefore(pathStart))) {
            selectedPaths.push(path);
          }
          path.skip();
        }
      });
      return selectedPaths;
    }).flat();
  }

  /** 
   * Takes the outermost node whose corresponding selection range is minimal for containing the selected text.
   * a      foo = bar
   * --b    foo
   *   --c  foo
   * 
   * In this example, when 'foo' is selected, b will be returned, since it is the outermost node that contains the
   * entire selection, but nothing more.
   */
  getOutermostPathContainingSelectionWithMinimalSelectionRange(startingPath, anchor, head) {
    const selectionStart = loc(anchor);
    const selectionEnd = loc(head);
    var currentPath = this.getInnermostPathContainingSelection(startingPath, anchor, head);
    currentPath.findParent(path => {
      const pathLocation = path.node.loc;
      const pathStart = loc(pathLocation.start);
      const pathEnd = loc(pathLocation.end);

      if (pathStart.isEqual(selectionStart) && selectionEnd.isEqual(pathEnd)) {
        currentPath = path;
      }

      return false;
    });
    return currentPath;
  }

  /**
   * Array of all children in depth first search order
   */
  forwardList(parentPath) {
    const linearizedPathList = [];
    parentPath.traverse({
      exit(path) {
        linearizedPathList.push(path);
      }
    });
    return linearizedPathList;
  }
  /**
   * Array of all children in reversed depth first search order
   */
  backwardList(parentPath) {
    const linearizedPathList = [];
    parentPath.traverse({
      enter(path) {
        linearizedPathList.push(path);
      }
    });
    return linearizedPathList.reverse();
  }
  /**
   * select the selection range of the next ast node after the current selection that satisfies a given condition
   * select previous selection instead of next, if reversed is set to true
   */
  selectNextASTNodeWith(condition, reversed) {
    const programPath = this.programPath;
    const pathList = reversed ? this.backwardList(programPath) : this.forwardList(programPath);

    const maxPaths = this.editor.listSelections().map(({ anchor, head }) => {

      const currentPath = this.getInnermostPathContainingSelection(programPath, anchor, head);

      let selectionStart = loc(anchor);
      let selectionEnd = loc(head);
      const pathLocation = currentPath.node.loc;
      const pathStart = loc(pathLocation.start);
      const pathEnd = loc(pathLocation.end);

      // do we fully select the current path?
      if (selectionStart.isEqual(pathStart) && selectionEnd.isEqual(pathEnd)) {
        return this.getNextASTNodeInListWith(condition, pathList, currentPath);
      } else {
        return currentPath;
      }
    });

    this.selectPaths(maxPaths);
  }

  getFirstSelectedIdentifier(startPath) {
    if (t.isIdentifier(startPath.node)) {
      return startPath;
    }
    var first;
    startPath.traverse({
      Identifier(path) {
        if (!first) {
          first = path;
          path.stop();
        }
      }
    });
    return first;
  }

  getAllIdentifiers(startPath) {
    var identifiers = [];
    /*if (startPath.node.type == "Identifier") {
      identifiers.push(startPath);
    }*/
    startPath.traverse({
      Identifier(path) {
        identifiers.push(path);
      }
    });
    return identifiers;
  }

  getDeclaration(identifier) {
    if (identifier.scope.hasBinding(identifier.node.name)) {
      return identifier.scope.getBinding(identifier.node.name).path;
    }
  }

  getBindings(startPath) {
    var identifier = this.getFirstSelectedIdentifier(startPath);
    if (identifier && identifier.scope.hasBinding(identifier.node.name)) {
      const binding = identifier.scope.getBinding(identifier.node.name);
      return [this.getFirstSelectedIdentifier(binding.path), ...binding.referencePaths, ...binding.constantViolations.map(this.getFirstSelectedIdentifier)];
    }
  }

  getNextASTNodeInListWith(condition, pathList, path) {
    const currentPathInList = pathList.find(pathInList => pathInList.node === path.node);
    const currentIndex = pathList.indexOf(currentPathInList);
    for (var i = currentIndex + 1; i < pathList.length; i++) {
      if (condition(path, pathList[i])) {
        return pathList[i];
      }
    }
    return pathList[pathList.length - 1];
  }

  /** 
   * Select the text corresponding to the given nodes in the editor
   */
  selectNodes(nodes) {
    const ranges = nodes.map(node => {
      const [anchor, head] = range(node.loc).asCM();
      return { anchor, head };
    });
    // #TODO: include primary selection
    if (ranges.length == 1) {
      this.editor.setSelection(ranges[0].head, ranges[0].anchor);
    } else {
      this.editor.setSelections(ranges);
    }
  }

  /** 
   * Select the text corresponding to the given paths in the editor
   */
  selectPaths(paths) {
    this.selectNodes(paths.map(path => path.node));
  }

  /** 
   * Get the path for the first method with the given name
   */
  getMethodPath(classPath, name) {
    let methodPath;
    classPath.traverse({
      ClassMethod(path) {
        //debugger;
        if (!methodPath && path.node.key.name == name) {
          methodPath = path;
        }
      }
    });
    return methodPath;
  }

  /** 
   * Get the path of the first file
   */
  getClassPath(programPath) {
    let classPath;
    programPath.traverse({
      ClassDeclaration(path) {
        if (!classPath) {
          classPath = path;
        }
      }
    });
    return classPath;
  }

  /*MD ### Shortcuts MD*/

  expandSelection() {
    const maxPaths = this.editor.listSelections().map(({ anchor, head }) => {

      const pathToShow = this.getInnermostPathContainingSelection(this.programPath, anchor, head);

      // go up again
      let selectionStart = loc(anchor);
      let selectionEnd = loc(head);
      return pathToShow.find(path => {
        const pathLocation = path.node.loc;
        const pathStart = loc(pathLocation.start);
        const pathEnd = loc(pathLocation.end);

        return pathStart.isStrictBefore(selectionStart) || selectionEnd.isStrictBefore(pathEnd);
      }) || pathToShow;
    });

    this.selectPaths(maxPaths);
  }

  reduceSelection() {
    const maxPaths = this.editor.listSelections().map(({ anchor, head }) => {
      const pathToShow = this.getInnermostPathContainingSelection(this.programPath, anchor, head);

      return this.getFirstChildOrSelf(pathToShow);
    });

    this.selectPaths(maxPaths);
  }

  selectNextASTNode(reversed) {
    return this.selectNextASTNodeWith(() => true, reversed);
  }

  selectNextASTNodeLikeThis(reversed) {
    return this.selectNextASTNodeWith((currentNode, nextNode) => currentNode.type == nextNode.type, reversed);
  }

  selectNextReference(reversed) {
    const { anchor, head } = this.editor.listSelections()[0];

    const selectedPath = this.getInnermostPathContainingSelection(this.programPath, anchor, head);

    const bindings = this.getBindings(selectedPath);
    if (bindings) {
      let sortedBindings = [...bindings].sort((a, b) => a.node.start - b.node.start);
      let index = sortedBindings.indexOf(selectedPath);
      index += reversed ? -1 : 1;
      index = (index + sortedBindings.length) % sortedBindings.length;
      this.selectPaths([sortedBindings[index]]);
    }
  }

  async selectDeclaration() {
    const { anchor, head } = this.editor.listSelections()[0];

    const selectedPath = this.getInnermostPathContainingSelection(this.programPath, anchor, head);
    const identifier = this.getFirstSelectedIdentifier(selectedPath);
    const identName = identifier.node.name;
    if(!identifier) {
      return;
    }

    const declaration = await this.getDeclaration(identifier);
    if (declaration) {
      this.selectPaths([declaration]);
    } else {
      let locationsArray = await this.getCorrespondingClasses(identName);
      let classPath = this.getClassPath(this.programPath);
      if (locationsArray.some(cl => cl.name == classPath.node.id.name)) {
        this.selectPaths([this.getMethodPath(classPath, identName)]);
      } else {
        locationsArray.forEach(cl => lively.openBrowser(cl.url, true, " " + identName));
      }
    }
  }

  selectBindings() {
    const { anchor, head } = this.editor.listSelections()[0];

    const selectedPath = this.getInnermostPathContainingSelection(this.programPath, anchor, head);

    const bindings = this.getBindings(selectedPath);
    if (bindings) {
      this.selectPaths(bindings);
    }
  }

  async findImports() {
    const { anchor, head } = this.editor.listSelections()[0];
    const selectedPath = this.getInnermostPathContainingSelection(this.programPath, anchor, head);

    debugger;
  }

  /*MD ## Factoring Menu MD*/

  async openMenu() {
    function fa(name, ...modifiers) {
      return `<i class="fa fa-${name} ${modifiers.map(m => 'fa-' + m).join(' ')}"></i>`;
    }

    const menuItems = [['selection to local variable', () => {
      menu.remove();
      this.extractExpressionIntoLocalVariable();
    }, '→', fa('share-square-o', 'flip-horizontal')], ['wrap into active expression', () => {
      menu.remove();
      this.wrapExpressionIntoActiveExpression();
    }, '→', fa('suitcase')], ['Rename', () => {
      menu.remove();
      this.selectBindings();
    }, 'Alt+R', fa('suitcase')], ['Extract Method', () => {
      menu.remove();
      this.extractMethod();
    }, 'Alt+M', fa('suitcase')], ['Generate', [['Testcase', () => {
      menu.remove();
      this.generateTestcase();
    }, '→', fa('suitcase')]]], ['Import', () => {
      menu.remove();
      this.findImports();
    }, '→', fa('suitcase')]];
    var menuPosition = this.codeMirror.cursorCoords(false, "window");

    const menu = await ContextMenu.openIn(document.body, { clientX: menuPosition.left, clientY: menuPosition.bottom }, undefined, document.body, menuItems);
    menu.addEventListener("DOMNodeRemoved", () => {
      this.focusEditor();
    });
  }

  /*MD ## Generations MD*/

  /*MD ### Generate Testcase MD*/
  generateTestcase() {
    const selection = this.getFirstSelection();
    const scrollInfo = this.scrollInfo;

    let testcase;
    this.sourceCode = this.sourceCode.transformAsAST(() => ({
      visitor: {
        Program: programPath => {
          testcase = this.compileTestCaseString();
          this.getPathBeforeCursor(programPath, selection.selectionStart).insertAfter(testcase);
        }
      }
    })).code;
    this.scrollTo(scrollInfo);
  }

  compileTestCaseString(templateEngine) {
    let explanationText = prompt("Enter test case explanation") || "explanation";
    return template("it(EXP, () => {\n" + "let put = 'code here';" + "})")({
      EXP: t.stringLiteral(explanationText)
    });
  }

  /*MD ## Transformations MD*/

  /*MD ### Extract Method MD*/
  findParameters(identifiers, surroundingMethod, actualSelections) {
    return identifiers.filter(identifier => {
      return identifier.scope.hasBinding(identifier.node.name) && !surroundingMethod.parentPath.scope.hasBinding(identifier.node.name);
    }).map(identifier => {
      return identifier.scope.getBinding(identifier.node.name).path;
    }).filter(bindingPath => {
      return !this.isSelected(bindingPath, actualSelections);
    }).map(identifierDeclaration => {
      return this.getFirstSelectedIdentifier(identifierDeclaration).node;
    });
  }

  findReturnValues(identifiers, surroundingMethod, actualSelections) {
    const bindings = [...new Set(identifiers.filter(identifier => {
      return identifier.scope.hasBinding(identifier.node.name) && !surroundingMethod.parentPath.scope.hasBinding(identifier.node.name);
    }).map(identifier => {
      return identifier.scope.getBinding(identifier.node.name);
    }))];

    return bindings.filter(binding => {
      const declarationInSelection = this.isSelected(binding.path, actualSelections);
      const constantViolationInSelection = binding.constantViolations.some(constantViolation => this.isSelected(constantViolation, actualSelections));
      const referenceOutsideSelection = binding.referencePaths.some(reference => !this.isSelected(reference, actualSelections));

      return !declarationInSelection && constantViolationInSelection || (constantViolationInSelection || declarationInSelection) && referenceOutsideSelection;
    }).map(binding => {
      return this.getFirstSelectedIdentifier(binding.path).node;
    });
  }

  createMethod(content, parameter, returnValues, scope) {
    var returnStatement;
    if (returnValues.length == 1) {
      returnStatement = t.returnStatement(returnValues[0]);
    } else if (returnValues.length > 1) {
      returnStatement = t.returnStatement(t.objectExpression(returnValues.map(i => t.objectProperty(i, i, false, true))));
    }

    content = content.concat(content[content.length - 1].insertAfter(returnStatement));

    const newMethod = t.classMethod("method", t.identifier("test"), parameter, t.blockStatement(content.map(p => p.node)));
    const methodPath = scope.insertAfter(newMethod)[0];
    for (let i = 0; i < content.length - 1; i++) {
      content[i].remove();
    }
    var methodCall;
    if (returnValues.length == 1) {
      methodCall = t.assignmentExpression("=", returnValues[0], t.callExpression(t.identifier("this.test"), parameter));
    } else if (returnValues.length > 1) {
      const objectPattern = t.objectPattern(returnValues.map(i => t.objectProperty(i, i, false, true)));
      const callExpression = t.callExpression(t.identifier("this.test"), parameter);

      methodCall = t.variableDeclaration("const", [t.variableDeclarator(objectPattern, callExpression)]);
    } else {
      methodCall = t.callExpression(t.identifier("this.test"), parameter);
    }
    content[content.length - 1].replaceWith(methodCall);
    return methodPath;
  }

  async extractMethod() {
    var newMethod;
    const scrollInfo = this.scrollInfo;
    this.sourceCode = this.sourceCode.transformAsAST(({ types: t, template }) => ({
      visitor: {
        Program: programPath => {
          const selectedPaths = this.getSelectedPaths(programPath);
          const actualSelections = selectedPaths.map(path => {
            const [anchor, head] = range(path.node.loc).asCM();
            return { anchor, head };
          });
          const identifiers = selectedPaths.map(this.getAllIdentifiers).flat();

          const surroundingMethod = selectedPaths[0].find(parent => {
            return parent.node.type == "ClassMethod";
          });
          const parameters = this.findParameters(identifiers, surroundingMethod, actualSelections);
          const returnValues = this.findReturnValues(identifiers, surroundingMethod, actualSelections);

          newMethod = this.createMethod(selectedPaths, [...new Set(parameters)], returnValues, surroundingMethod);
        }
      }
    })).code;

    // this.selectPaths([newMethod]); <- currently not possible, because we replaced the sourceCode
    this.scrollTo(scrollInfo);
  }

  /*MD ### Extract Variable MD*/
  async extractExpressionIntoLocalVariable() {
    const selection = this.getFirstSelection();
    let done = false;

    const scrollInfo = this.scrollInfo;

    let pathLocationToBeExtracted;
    const res = this.sourceCode.transformAsAST(({ types: t }) => ({
      visitor: {
        Expression: path => {
          if (!done) {
            const isSelectedPath = this.isPathExactlySelected(path, selection);
            if (isSelectedPath) {
              pathLocationToBeExtracted = path.getPathLocation();

              path.find(p => {
                const parentPath = p.parentPath;
                if (!parentPath) {
                  return false;
                }

                function ensureBlock(body) {
                  if (!body.node) return false;

                  if (body.isBlockStatement()) {
                    return false;
                  }

                  const statements = [];
                  if (body.isStatement()) {
                    statements.push(body.node);
                    const blockNode = t.blockStatement(statements);
                    body.replaceWith(blockNode);
                    return true;
                  } else if (body.parentPath.isArrowFunctionExpression() && body.isExpression()) {
                    statements.push(t.returnStatement(body.node));
                    const blockNode = t.blockStatement(statements);
                    body.replaceWith(blockNode);
                    return true;
                  } else {
                    throw new Error("I never thought this was even possible.");
                  }
                }

                const targetLocation = path.getPathLocation();
                const blockLocation = p.getPathLocation();
                if (p.parentKey === 'body' && (parentPath.isFor() || parentPath.isWhile())) {
                  const becameABlock = ensureBlock(p);
                  if (becameABlock) {
                    pathLocationToBeExtracted = blockLocation + '.body[0]' + targetLocation.replace(blockLocation, '');
                  }
                  return true;
                }
                if (p.parentKey === 'body' && parentPath.isFunction()) {
                  const becameABlock = ensureBlock(p);
                  if (becameABlock) {
                    pathLocationToBeExtracted = blockLocation + '.body[0].argument' + targetLocation.replace(blockLocation, '');
                  }
                  return true;
                }
                if ((p.parentKey === 'consequent' || p.parentKey === 'alternate') && parentPath.isIfStatement()) {
                  const becameABlock = ensureBlock(p);
                  if (becameABlock) {
                    pathLocationToBeExtracted = blockLocation + '.body[0]' + targetLocation.replace(blockLocation, '');
                  }
                  return true;
                }
              });

              done = true;
            }
          }
        }
      }
    }));

    if (!pathLocationToBeExtracted) {
      lively.warn('No Expression to extract found.');
      return;
    }

    const pathLocationsToSelect = [];
    const resultExtracted = res.code.transformAsAST(({ types: t, template }) => ({
      visitor: {
        Program: programPath => {
          const path = this.pathByLocationFromProgram(programPath, pathLocationToBeExtracted);
          let value = '';
          path.traverse({
            Identifier(p) {
              value += '-' + p.node.name;
            }
          });
          if (value.length > 0) {
            // #TODO: ensure unique identifier
            value = value.camelCase();
          } else {
            value = path.scope.generateUidIdentifier('temp').name;
          }
          const identifier = t.Identifier(value);
          const decl = template('const ID = INIT;')({
            ID: identifier,
            INIT: path.node
          });

          let referree = t.Identifier(value);

          path.replaceWith(referree);
          const insertedDeclaration = path.getStatementParent().insertBefore(decl)[0];
          const insertedDeclarationIdentifier = insertedDeclaration.get('declarations')[0].get('id');

          pathLocationsToSelect.push(insertedDeclarationIdentifier.getPathLocation());
          pathLocationsToSelect.push(path.getPathLocation());
        }
      }
    }));
    this.sourceCode = resultExtracted.code;

    const pathsToSelect = this.pathLocationsToPathes(pathLocationsToSelect);

    this.selectPaths(pathsToSelect);
    this.focusEditor();
    this.scrollTo(scrollInfo);
  }

  async wrapExpressionIntoActiveExpression() {
    const selection = this.getFirstSelection();
    let done = false;

    const scrollInfo = this.scrollInfo;

    let pathLocationToBeExtracted;
    const res = this.sourceCode.transformAsAST(() => ({
      visitor: {
        Expression: path => {
          if (!done) {
            const isSelectedPath = this.isPathExactlySelected(path, selection);
            if (isSelectedPath) {
              pathLocationToBeExtracted = path.getPathLocation();
              done = true;
            }
          }
        }
      }
    }));

    if (!pathLocationToBeExtracted) {
      lively.warn('No `Expression` to wrap found.');
      return;
    }

    const pathLocationsToSelect = [];
    const resultExtracted = res.code.transformAsAST(({ template }) => ({
      visitor: {
        Program: programPath => {
          const path = this.pathByLocationFromProgram(programPath, pathLocationToBeExtracted);
          const ae = template('aexpr(() => EXPR)')({
            EXPR: path.node
          }).expression;

          path.replaceWith(ae);

          pathLocationsToSelect.push(path.getPathLocation());
        }
      }
    }));
    this.sourceCode = resultExtracted.code;

    const pathsToSelect = this.pathLocationsToPathes(pathLocationsToSelect);

    this.selectPaths(pathsToSelect);
    this.focusEditor();
    this.scrollTo(scrollInfo);
  }

  /*MD ## Accessors MD*/

  get sourceCode() {
    return this.livelyCodeMirror.value;
  }
  set sourceCode(text) {
    return this.livelyCodeMirror.value = text;
  }

  focusEditor() {
    this.livelyCodeMirror.focus();
  }

  get scrollInfo() {
    return this.codeMirror.getScrollInfo();
  }
  scrollTo(scrollInfo) {
    this.codeMirror.scrollIntoView({
      left: scrollInfo.left,
      top: scrollInfo.top,
      right: scrollInfo.left + scrollInfo.width,
      bottom: scrollInfo.top + scrollInfo.height
    });
  }

  /*MD ## Utilities MD*/

  isSelected(path, selections = null) {
    if (!selections) {
      selections = this.editor.listSelections();
    }
    const pathLocation = path.node.loc;
    const pathStart = loc(pathLocation.start);
    const pathEnd = loc(pathLocation.end);
    for (const range of selections) {
      const selectionStart = loc(range.anchor);
      const selectionEnd = loc(range.head);
      if (!(pathEnd.isBefore(selectionStart) || selectionEnd.isBefore(pathStart))) {
        return true;
      }
    }
    return false;
  }

  getFirstSelection() {
    const { anchor, head } = this.editor.listSelections()[0];
    const selectionStart = loc(anchor);
    const selectionEnd = loc(head);
    return { selectionStart, selectionEnd };
  }

  isPathExactlySelected(path, { selectionStart, selectionEnd }) {
    const pathLocation = path.node.loc;
    if (!pathLocation) {
      return;
    }

    const pathStart = loc(pathLocation.start);
    const pathEnd = loc(pathLocation.end);
    return pathStart.isEqual(selectionStart) && selectionEnd.isEqual(pathEnd);
  }

  pathByLocationFromProgram(programPath, location) {
    let path = programPath;
    const reg = /(\.[A-Za-z0-9]+|(\[[0-9]+\]))/ig;
    let result;
    while ((result = reg.exec(location)) !== null) {
      let part = result[0];
      if (part.startsWith('.')) {
        part = part.replace('.', '');
        path = path.get(part);
      } else {
        part = part.replace(/\[|\]/ig, '');
        part = parseInt(part);
        path = path[part];
      }
    }

    return path;
  }

  pathLocationsToPathes(pathLocations) {
    const paths = [];

    this.sourceCode.traverseAsAST({
      Program: path => {
        pathLocations.forEach(location => {
          paths.push(this.pathByLocationFromProgram(path, location));
        });
      }
    });

    return paths;
  }

  async getCorrespondingClasses(className) {
    let index = await FileIndex.current();
    let locations = index.db.classes.filter(cl => {return cl.methods.some(me => me.name == className);});
    locations.filter(ea => ea.url.match(lively4url)) //filter local files
    return await locations.toArray();
  }
}