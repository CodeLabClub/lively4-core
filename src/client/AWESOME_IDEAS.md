# AWESOME IDEAS

---

### No Compromizes?!

- No more hostage to the past
  - can we live up on that ideal?
  - How to break the chains of our own previous experience?
    - experience helps via piggybacking, but constraints our thinking -> we always choose the same/familiar paths
  
### Principles:

- Eat your own dogfood
- Question Status Quo
  - Language Design as User-Centered Design Process


### Values:

- Time Travel
- Live Programming
- Lively4: Computational Power for everyone
  - Services/Deployment of Computations
- 'Nothing is carved in stone'-Attitude
  - contradicts with **Immediate Impact**
    - What's the compromize here?
      - Is there even one?
- state of the research: build the fanciest debugger


### Non-Programmer Goals

- Look at Natural Programming Project, e.g.: #ToRead
  - Pane Dissertation
  - Whyline Dis
- BoardGame Study

### Solver Backends

z.B.:

- Cassowary
- Backtalk
- Prolog-like Backend/Solver/Clingo
  - to solve Production Rules

-> don't reinvent this yourself!
  -> People spend time and energy on these technologies, so (re-)use them

-> does this go into the direction of knowledge-intensive programming (Wolfram-like), e.g. by including Wordnet

### Production Rules as solid foundation

Production Rules can be used internally!

- Prior work on incremental Prod. Rules Solvers #ToRead
- for solid foundation
  - research school:
    - solidify foundation
    - time travel
    - to double check our goals (Myers)

---

One Core Aspect: Reduce Friction/Increase Factorability (also through better comprehension)

Use a Refined/Rethinked Triple Data Model to shake things up.

- Are we honest here? (Do we try to solve an actual problem?)
  - -> Do not design for the sake of designing it/to prove we can do something
    - Language Designers are programmers that feel joy in cracking tough problems and have fun in building strutcures
      - -> restraint
        - listen to Drive to Work Podcast

### Code as Structure

- not just text
  - -> Triples as natural conclusion
- Properties usually defined by strings, but now as arbitrary objects
  - SPO
    - for each combination just 1 object?
- AST as first-class entity
  - read only?


Working Hypothesis: Programmers are people, too. What helps to support natural thinking helps them too.
E.g. Probability theory is hard to grasp despite being useful.

---

Whyline-like methods as a core goal:

- ... #TODO

### Do some Planning:

- How can this become reality?
- What are the first steps?
  - Studies/Surveys
  - Starting at data (for usecase)
- Which people have to sign off to that?
  - also: **gather allies**
    - implementation:
      - lively4
    - thinkers
      - Patrick

